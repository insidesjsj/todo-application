4.1 REST API 사용 기법
인증
: 당신이 누구인가에 대한 것.
- 손님이 와서 벨을 누른다. 벨을 누르는 행위는 로그인 요청
- 나는 인터콤을 통해 손님이 누구인지 확인한다. 내가 아는 안전한 사람이라면 집으로 들일 수 있게 해준다. 이것이 인증

인가
: 인증된 사용자가 사용할 수 있는 데이터와 기능을 정의

----------------------------------------------------------
학습 내용
- Basic 인증
- Bearer 인증
- JSON 웹 토큰


4.1.1 Basic 인증
: 모든 HTTP 요청에 아이디와 비밀번호를 같이 보내는 것.

- 최초 로그인 한 후 HTTP 요청 헤더의 Authorization: 부분에 'Basic <ID>:<Password>'처럼 아이디와 비밀번호를 콜론으로 이어붙인 후 Base64로 인코딩한 문자열을 함께 보낸다.
- 이 요청을 수신한 서버는 인코딩된 문자열을 디코딩한 후 데이터베이스 또는 인증 서버의 레코드와 비교.
- 인코딩은 보안 목적 X. 누구나 디코더만 있으면 원래 아이디와 비밀번호를 알아낼 수 있어 Basic 인증은 반드시 HTTPS와 사용해야 한다.
- 사용자를 로그아웃 시킬 수 없음. 모든 요청이 일종의 로그인 요청이기 때문이다.
- 사용자의 계정 정보가 있는 저장 장소, 인증 서버와 인증 DB에 과부하가 걸릴 확률이 높다. 서비스가 커지고 마이크로 서비스로 쪼개지면 문제가 커진다.


4.1.2 토큰 기반 인증
: 사용자를 구별할 수 있는 문자열.

- 토큰은 최초 로그인 시 서버가 만들어 준다.
- 클라이언트는 이후 요청에 아이디와 비밀번호 대신 토큰을 계속 넘겨 자신이 인증된 사용자임을 알린다.
- Basic Auth를 이용한 로그인과 무엇이 다른가?
1) id, pw를 매번 네트워크를 통해 전송해야 할 필요가 없으므로 보안 측면에서 좀 더 안전함.
2) 서버가 토큰을 마음대로 생성할 수 있으므로 사용자의 인가 정보 또는 유효 시간을 정해 관리할 수 있음.

- 하지만 Basic 인증에서 마주한 스케일 문제를 해결할 수 없음.


4.1.3 JSON 웹 토큰
: 서버에서 전자 서명된 토큰을 이용하면 인증에 따른 스케일 문제를 해결 할 수 있음
=> 이렇게 전자 서명된 토큰 중 하나가 "JSON 웹 토큰"

- {header}.{payload}.{signature}로 구성

Header
- typ: Type을 줄인 말로 토큰의 타입을 의미
- alg: Algorithm을 줄인 말로 토큰의 서명을 발행하는 데 사용된 해시 알고리듬의 종류

Payload
- sub: Subject의 줄인 말, 토큰의 주인. sub는 ID처럼 유일한 식별자여야 한다.
- iss: Issuer을 줄인 말, 토큰을 발행한 주체. 페이스북이 발행했다면 facebook
- iat: issued at을 줄인 말, 토큰이 발행된 날짜와 시간
- exp: expiration을 줄인 말. 토큰이 만료되는 시간

Signature
: Issuer가 발행한 서명. 토큰의 유효성 검사에 사용.

전자 서명: {헤더}.{페이로드}와 시크릿키를 이용해 해시 함수에 돌린 암호화한 결과 값
시크릿키: 나만 알고 있는 문자열, 비밀번호 같은 것.

1) 최초 로그인 시 서버는 사용자의 아이디와 비밀번호를 서버에 저장된 아이디와 비밀번호에 비교해 인증.

2) 인증된 사용자인 경우 사용자의 정보를 이용해 {헤더}.{페이로드} 부분을 작성하고 자신의 시크릿키로 {헤더}.{페이로드} 부분을 전자서명.

3) 전자 서명의 결과로 나온 값을 {헤더}.{페이로드}.{서명}으로 이어붙이고 Base64로 인코딩한 후 반환.

4) 이후에 누군가가 이 토큰으로 리소스 접근 요청 시 -> 서버는 일단 이 토큰을 Basse64로 디코딩

5) 디코딩해서 얻은 JSON을 {헤더}.{페이로드}와 {서명} 부분으로 나눈다.

6) 서버는 방금 만든 전자 서명을 HTTP 요청이 갖고 온 {서명} 부분과 비교해 이 토큰의 유효성을 검사한다. 일치하면 토큰이 위조되지 않았다는 뜻이다.

