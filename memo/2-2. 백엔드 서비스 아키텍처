2-2 백엔드 서비스 아키텍처

학습내용
- 레이어드 아키텍처 패턴
- REST 아키텍처 스타일
- 스프링 어노테이션
- JAP와 스프링 Data JPA

실습내용
- Model/Entity와 DTO 클래스
- Controller, Service, Persistence
- 테스팅용 REST API

----------------------------------------------------
2.2.1 레이어드 아키텍처 패턴
: 애플리케이션을 구성하는 요소들을 수평으로 나눠 관리하는 것

----------------------------------------------------
2.2.2 모델, 엔티티, DTO
: 기능에 따라 분류, 이름에 큰 의미를 두지 말고 무엇을 위한 클래스인지가 중요하다.

비즈니스 애플리케이션의 클래스
1) 일을 하는 클래스 (기능을 수행)
- 컨트롤러, 서비스, 퍼시스턴스처럼 로직을 수행

2) 데이터를 담는 클래스
- 말 그대로 데이터만 가지고 있음


1. 모델과 엔티티
- 이 프로젝트에서는 모델과 엔티티를 한 클래스에 구현
- 따라서 모델은 비즈니스 데이터를 담는 역할과 데이터베이스의 테이블과 스키마를 표현하는 두 역할을 한다


1) 어노테이션 설명
@Builder
: 오브젝트 생성을 위한 디자인 패턴 중 하나
TodoEntity todo = TodoEntity.builder()
                    .id("t-245235")
                    .userId("developer")
                    .title("Implement Model")
                    .build();

@NoArgsConstructor
: 매개변수가 없는 생성자

@AllArgsConstructor
: 모든 멤버 변수를 매개변수로 받는 생성자 구현

@Data
: 클래스 멤버 변수의 Getter/Setter 메서드를 구현

2. DTO (DAta Transfer Object)

2-1) 왜 그냥 모델을 리턴하지 않고 DTO로 변환하는 것일까?
1) 비즈니스 로직을 캡슐화 하기 위함
- 모델은 데이터베이스 테이블 구조와 매우 유사.
- 대부분의 비즈니스는 외부인이 자사의 데이터베이스의 스키마를 아는 것을 원치 않음.
- 이 때 DTO처럼 다른 오브젝트로 바꿔 반환하면 외부 사용자에게 서비스 내부의 로직, 데이터베이스의 구조 등을 숨길 수 있다.

2) 클라이언트가 필요한 정보를 모델이 전부 포함하지 않는 경우가 많기 때문이다.
- 대표적인 예 : 에러 메시지
- 서비스 실행 중 사용자 에러가 나면 이 에러메시지를 어디에 포함하는가?
- 모델은 서비스 로직과 관련 없기 때문에 모델에 담기는 애매하다
- 이런 경우 DTO에 에러 메시지 필드를 선언하고 DTO에 포함


2-2) TodoDTO 구현
TodoDTO에는 userID가 없다.
- 이 프로젝트는 이후 스프링 시큐리티를 이용해 인증을 구현한다
- 따라서 사용자가 자기 아이디를 넘겨주지 않아도 인증이 가능하다.
- userId는 애플리케이션과 데이터베이스에서 사용자를 구별하는 고유 식별자로 사용하기 때문에 숨길 수 있다면 숨기는 것이 보안상 맞다.

2-3) ResponseDTO 구현
: HTTP 응답으로 사용할 DTO

---------------------------------------------------
2.2.3 REST API (Representational State Transfer)

Representational (표현): 자원(데이터 또는 서비스)이 특정 형식(일반적으로 XML 또는 JSON)으로 표현된다는 아이디어입니다.
                        클라이언트가 서버로부터 자원을 요청하면, 서버는 해당 자원을 적절한 표현으로 응답합니다.

State (상태): 시스템의 상태를 나타냅니다.
             REST 아키텍처에서는 클라이언트와 서버 간의 통신에서 상태 정보를 주고받지 않음으로써 상태를 관리합니다.
             이것은 서버가 각 요청을 독립적인 것으로 처리하고 클라이언트의 상태를 저장하지 않는다는 것을 의미합니다.
             클라이언트의 상태는 요청 내에 포함된 정보만으로 충분해야 합니다.

Transfer (전송): 클라이언트와 서버 간에 자원의 상태를 전송하기 위해 네트워크 프로토콜을 사용한다는 의미입니다.
                REST에서는 주로 HTTP 프로토콜을 사용하며, HTTP 메서드(GET, POST, PUT, DELETE 등)를 통해 자원을 조작합니다.


REST 제약조건
1) 클라이언트 서버 [Client-Server]
: 리소스를 관리하는 서버가 존재하고, 다수의 클라이언트가 리소스를 소비하려고 네트워크를 통해 서버에 접근하는 구조를 의미

2) 상태가 없는 [Stateless]
: 클라이언트가 서버에 요청을 보낼 때 이전 요청의 영향을 받지 않음을 의미.

3) 캐시 되는 데이터 [Cacheable]
: 서버에서 리소스를 리턴할 때 캐시가 가능한지 아닌지 명시할 수 있어야 함

4) 일관적인 인터페이스 [Uniform Interface]
: 시스템 또는 애플리케이션 리소스에 접근할 때 인터페이스가 일관적이어야 한다.

5) 레이어 시스템 [Layered System]
: 클라이언트가 서버에 요청을 할 때 여러개의 레이어로 된 서버를 거칠 수 있다. 이 사이의 레이어들은 요청과 응답에 어떤 영향을 미치지 않으며 클라이언트는 서버의 레이어 존재 유무를 알지 못한다.

6) 코드-온-디맨드 [Code-On-Demand](선택사항)
: 선택사항) 클라이언트는 서버에 코드를 요청할 수 있고, 서버가 리턴한 코드를 실행할 수 있다.


REST는 HTTP와 다르다. REST는 HTTP를 이용해 구현하기 쉽고 대부분 그렇게 구현하지만 엄밀히 말하면 REST는 아키텍처이고,
HTTP는 REST 아키텍처를 구현할 때 사용하면 쉬운 프로토콜이다.

---------------------------------------------------------


