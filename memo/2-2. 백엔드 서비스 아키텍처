2-2 백엔드 서비스 아키텍처

학습내용
- 레이어드 아키텍처 패턴
- REST 아키텍처 스타일
- 스프링 어노테이션
- JAP와 스프링 Data JPA

실습내용
- Model/Entity와 DTO 클래스
- Controller, Service, Persistence
- 테스팅용 REST API

----------------------------------------------------
2.2.1 레이어드 아키텍처 패턴
: 애플리케이션을 구성하는 요소들을 수평으로 나눠 관리하는 것

----------------------------------------------------
2.2.2 모델, 엔티티, DTO
: 기능에 따라 분류, 이름에 큰 의미를 두지 말고 무엇을 위한 클래스인지가 중요하다.

비즈니스 애플리케이션의 클래스
1) 일을 하는 클래스 (기능을 수행)
- 컨트롤러, 서비스, 퍼시스턴스처럼 로직을 수행

2) 데이터를 담는 클래스
- 말 그대로 데이터만 가지고 있음


1. 모델과 엔티티
- 이 프로젝트에서는 모델과 엔티티를 한 클래스에 구현
- 따라서 모델은 비즈니스 데이터를 담는 역할과 데이터베이스의 테이블과 스키마를 표현하는 두 역할을 한다


1) 어노테이션 설명
@Builder
: 오브젝트 생성을 위한 디자인 패턴 중 하나
TodoEntity todo = TodoEntity.builder()
                    .id("t-245235")
                    .userId("developer")
                    .title("Implement Model")
                    .build();

@NoArgsConstructor
: 매개변수가 없는 생성자

@AllArgsConstructor
: 모든 멤버 변수를 매개변수로 받는 생성자 구현

@Data
: 클래스 멤버 변수의 Getter/Setter 메서드를 구현

2. DTO (DAta Transfer Object)

2-1) 왜 그냥 모델을 리턴하지 않고 DTO로 변환하는 것일까?
1) 비즈니스 로직을 캡슐화 하기 위함
- 모델은 데이터베이스 테이블 구조와 매우 유사.
- 대부분의 비즈니스는 외부인이 자사의 데이터베이스의 스키마를 아는 것을 원치 않음.
- 이 때 DTO처럼 다른 오브젝트로 바꿔 반환하면 외부 사용자에게 서비스 내부의 로직, 데이터베이스의 구조 등을 숨길 수 있다.

2) 클라이언트가 필요한 정보를 모델이 전부 포함하지 않는 경우가 많기 때문이다.
- 대표적인 예 : 에러 메시지
- 서비스 실행 중 사용자 에러가 나면 이 에러메시지를 어디에 포함하는가?
- 모델은 서비스 로직과 관련 없기 때문에 모델에 담기는 애매하다
- 이런 경우 DTO에 에러 메시지 필드를 선언하고 DTO에 포함


2-2) TodoDTO 구현
TodoDTO에는 userID가 없다.
- 이 프로젝트는 이후 스프링 시큐리티를 이용해 인증을 구현한다
- 따라서 사용자가 자기 아이디를 넘겨주지 않아도 인증이 가능하다.
- userId는 애플리케이션과 데이터베이스에서 사용자를 구별하는 고유 식별자로 사용하기 때문에 숨길 수 있다면 숨기는 것이 보안상 맞다.

2-3) ResponseDTO 구현
: HTTP 응답으로 사용할 DTO