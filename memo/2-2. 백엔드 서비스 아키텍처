2-2 백엔드 서비스 아키텍처

학습내용
- 레이어드 아키텍처 패턴
- REST 아키텍처 스타일
- 스프링 어노테이션
- JAP와 스프링 Data JPA

실습내용
- Model/Entity와 DTO 클래스
- Controller, Service, Persistence
- 테스팅용 REST API

----------------------------------------------------
2.2.1 레이어드 아키텍처 패턴
: 애플리케이션을 구성하는 요소들을 수평으로 나눠 관리하는 것

----------------------------------------------------
2.2.2 모델, 엔티티, DTO
: 기능에 따라 분류, 이름에 큰 의미를 두지 말고 무엇을 위한 클래스인지가 중요하다.

비즈니스 애플리케이션의 클래스
1) 일을 하는 클래스 (기능을 수행)
- 컨트롤러, 서비스, 퍼시스턴스처럼 로직을 수행

2) 데이터를 담는 클래스
- 말 그대로 데이터만 가지고 있음


1. 모델과 엔티티
- 이 프로젝트에서는 모델과 엔티티를 한 클래스에 구현
- 따라서 모델은 비즈니스 데이터를 담는 역할과 데이터베이스의 테이블과 스키마를 표현하는 두 역할을 한다


1) 어노테이션 설명
@Builder
: 오브젝트 생성을 위한 디자인 패턴 중 하나
TodoEntity todo = TodoEntity.builder()
                    .id("t-245235")
                    .userId("developer")
                    .title("Implement Model")
                    .build();

@NoArgsConstructor
: 매개변수가 없는 생성자

@AllArgsConstructor
: 모든 멤버 변수를 매개변수로 받는 생성자 구현

@Data
: 클래스 멤버 변수의 Getter/Setter 메서드를 구현

2. DTO (DAta Transfer Object)

2-1) 왜 그냥 모델을 리턴하지 않고 DTO로 변환하는 것일까?
1) 비즈니스 로직을 캡슐화 하기 위함
- 모델은 데이터베이스 테이블 구조와 매우 유사.
- 대부분의 비즈니스는 외부인이 자사의 데이터베이스의 스키마를 아는 것을 원치 않음.
- 이 때 DTO처럼 다른 오브젝트로 바꿔 반환하면 외부 사용자에게 서비스 내부의 로직, 데이터베이스의 구조 등을 숨길 수 있다.

2) 클라이언트가 필요한 정보를 모델이 전부 포함하지 않는 경우가 많기 때문이다.
- 대표적인 예 : 에러 메시지
- 서비스 실행 중 사용자 에러가 나면 이 에러메시지를 어디에 포함하는가?
- 모델은 서비스 로직과 관련 없기 때문에 모델에 담기는 애매하다
- 이런 경우 DTO에 에러 메시지 필드를 선언하고 DTO에 포함


2-2) TodoDTO 구현
TodoDTO에는 userID가 없다.
- 이 프로젝트는 이후 스프링 시큐리티를 이용해 인증을 구현한다
- 따라서 사용자가 자기 아이디를 넘겨주지 않아도 인증이 가능하다.
- userId는 애플리케이션과 데이터베이스에서 사용자를 구별하는 고유 식별자로 사용하기 때문에 숨길 수 있다면 숨기는 것이 보안상 맞다.

2-3) ResponseDTO 구현
: HTTP 응답으로 사용할 DTO

---------------------------------------------------
2.2.3 REST API (Representational State Transfer)

Representational (표현): 자원(데이터 또는 서비스)이 특정 형식(일반적으로 XML 또는 JSON)으로 표현된다는 아이디어입니다.
                        클라이언트가 서버로부터 자원을 요청하면, 서버는 해당 자원을 적절한 표현으로 응답합니다.

State (상태): 시스템의 상태를 나타냅니다.
             REST 아키텍처에서는 클라이언트와 서버 간의 통신에서 상태 정보를 주고받지 않음으로써 상태를 관리합니다.
             이것은 서버가 각 요청을 독립적인 것으로 처리하고 클라이언트의 상태를 저장하지 않는다는 것을 의미합니다.
             클라이언트의 상태는 요청 내에 포함된 정보만으로 충분해야 합니다.

Transfer (전송): 클라이언트와 서버 간에 자원의 상태를 전송하기 위해 네트워크 프로토콜을 사용한다는 의미입니다.
                REST에서는 주로 HTTP 프로토콜을 사용하며, HTTP 메서드(GET, POST, PUT, DELETE 등)를 통해 자원을 조작합니다.


REST 제약조건
1) 클라이언트 서버 [Client-Server]
: 리소스를 관리하는 서버가 존재하고, 다수의 클라이언트가 리소스를 소비하려고 네트워크를 통해 서버에 접근하는 구조를 의미

2) 상태가 없는 [Stateless]
: 클라이언트가 서버에 요청을 보낼 때 이전 요청의 영향을 받지 않음을 의미.

3) 캐시 되는 데이터 [Cacheable]
: 서버에서 리소스를 리턴할 때 캐시가 가능한지 아닌지 명시할 수 있어야 함

4) 일관적인 인터페이스 [Uniform Interface]
: 시스템 또는 애플리케이션 리소스에 접근할 때 인터페이스가 일관적이어야 한다.

5) 레이어 시스템 [Layered System]
: 클라이언트가 서버에 요청을 할 때 여러개의 레이어로 된 서버를 거칠 수 있다. 이 사이의 레이어들은 요청과 응답에 어떤 영향을 미치지 않으며 클라이언트는 서버의 레이어 존재 유무를 알지 못한다.

6) 코드-온-디맨드 [Code-On-Demand](선택사항)
: 선택사항) 클라이언트는 서버에 코드를 요청할 수 있고, 서버가 리턴한 코드를 실행할 수 있다.


REST는 HTTP와 다르다. REST는 HTTP를 이용해 구현하기 쉽고 대부분 그렇게 구현하지만 엄밀히 말하면 REST는 아키텍처이고,
HTTP는 REST 아키텍처를 구현할 때 사용하면 쉬운 프로토콜이다.

---------------------------------------------------------
2.2.4 컨트롤러 레이어: 스프링 REST API 컨트롤러
HTTP는 GET/POST/PUT/DELETE/OPTIONS 등과 같은 메서드와 URI를 이용해 서버에 HTTP 요청을 보낼 수 있다.
그렇다면 서버는 이 요청을 받은 후 어떻게 처리해야 할까?

@RestControlloer
: 해당 컨트롤러가 RestController임을 명시. http와 관련된 코드 및 요청/응답 매핑르 스프링이 알아서 해준다.

@GetMapping
: 해당 메소드의 리소스와 HTTP 메서드를 지정. 클라이언트가 이 리소스에 대해 Get 메서드로 요청하면 @GetMapping에 연결된 컨트롤러가 실행.


- 매개변수를 넘겨받는 방법
@PathVariable
: URL 파라미터(/{id})로 넘어오는 값을 변수로 받을 수 있다.

@RequestParam
: 쿼리스트링 형태로 값을 변수로 받을 수 있음

@RequsetBody
: 반환하고자 하는 리소스가 복잡할 때 사용(오브젝트처럼 복잡한 자료형)

@ResponseBody
: @RestController의 내부를 들여다보면 크게 두 어노테이션의 조합으로 이뤄져 있다.
1) @Controller
2) @ResponseBody
: 이 클래스의 메서드가 리턴하는 것은 웹서비스의 ResponseBody라는 뜻. 메서드가 리턴할 때 스프링은 리턴된 오브젝트를 JSON의 형태로 바꾸고 HttpResponse에 담아 반환

-----------------------------------------------
2.2.5 서비스 레이어 - 비즈니스 로직
: 서비스 레이어는 컨트롤러와 퍼시스턴스 사이에서 비즈니스 로직을 수행하는 역할을 한다.

@Service
: 스트레오타입 어노테이션.
@Component 어노테이션을 갖고 있는데, 비교 했을 때 특별한 기능 차이는 없다.
단지 이 클래스는 스프링 컴포넌트이며 기능적으로는 비즈니스 로직을 수행하는 서비스 레이어임을 알려준다.

------------------------------------------------

2.2.6 퍼시스턴스 레이어: 스프링 데이터 JPA
: 데이터베이스 테이블을 자바 내에서 사용하려면 ORM을 엔티티 마다 해줘야 한다.
JPA는 반복해서 데이터베이스 쿼리를 보내 ResultSet을 파싱해야 하는 개발자들의 노고를 덜어준다.

1) TodoEntity.java 수정
- 보통 데이터 베이스 테이블마다 그에 상응하는 엔티티 클래스가 존재한다.
- ORM이 엔티티를 보고 어떤 테이블의 어떤 필드에 매핑해야 하는지 알 수 있어야 한다.
- 어떤 필드가 기본 키, 외래 키 인지도 구분할 수 있어야 한다.
- 이런 데이터베이스 테이블 스키마에 관한 정보는 javax.persistence가 제공하는 JPA 관련 어노테이션을 이용해 정의한다.

1-1) 자바 클래스를 엔티티로 정의할 때 주의해야 할 점
[1] 클래스에는 매개변수가 없는 생성자, NoargsConstructor 가 필요.
[2] Getter / Setter 필요
[3] 기본 키 지정

2) TodoRepository 생성
JpaRepository는 인터페이스이고, 이 인터페이스를 사용하려면 새 인터페이스를 작성해 JpaRepository를 extend 해야 한다.

JpaRepository<T,ID>
T: 테이블에 매핑 될 엔티티 클래스
ID: 이 엔티티의 기본 키의 타입

@Repository
: @Component 어노테이션의 특별 케이스다. 스프링이 관리

3) TodoService에서 TodoRepository 사용
JpaRepository는 기본적인 데이터베이스 오퍼레이션 인터페이스 제공. save, findById, findAll 등이 기본적으로 제공


4) 그렇다면 기본적으로 제공해주는 쿼리가 아닌 쿼리는 어떻게 작성할까?
4-1) TodoRepository에서 findByUserId 라는 메서드 작성
4-2) @Query를 이용한 쿼리 메서드 작성

-----------------------------------------
2.3
Logger 설정
: 디버깅을 위한 로그 설정으로 Slf4j 로그 라이브러리 사용

2.3.1 Create Todo 구현
1) 퍼시스턴스 구현
- 이미 구현한 TodoRepository 사용

2) 서비스 구현
create 메서드 작성
- 검증(validation) : 넘어온 엔티티가 유효한지 검사하는 로직
- sava() : 엔티티를 데이터베이스에 저장하고 로그를 남긴다.
- findByUserId() : 저장된 엔티티를 포함하는 새 리스트를 리턴한다.

3) 컨트롤러 구현
컨트롤러는 사용자에게서 TodoDTO를 요청 바디로 넘겨받고, 이를 TodoEntity로 변환해 저장해야 한다.
또 TodoService의 create()가 리턴하는 TodoEntity를 TodoDTO로 변환해 리턴해야 한다.

3-1) TodoDTO, toEntity 메서드 작성

3-2) TodoController - createTodo

3-3) 테스팅
{
    "title" : "새포스트 1"
}

* GET 요청 / POST 요청 잘 구분하자 *

----------------------------------------------
2.3.2. Retrieve Todo 구현
: Todo 리스트를 검색하는 리포지터리, 서비스, 컨트롤러를 구현

1) 퍼시스턴스 구현
- 이미 작성한 TodoRepository에서 findByUserId() 메서드 사용

2) 서비스 구현
- repository에서 findByUserId를 호출하는 retrieve 메서드를 작성

3) 컨트롤러 구현
- 새로운 GET 메서드 생성

------------------------------------------------
2.3.3 Update Todo 구현

1) 퍼시스턴스 구현
- 이미 작성한 TodoRepository에서 save(), findByUserId() 메서드 사용

2) 서비스 구현
: update() 메서드 작성

Optional: null이 올 수 있는 값을 감싸는 Wrapper 클래스. 참조하더라도 NPE가 발생하지 않도록 도와준다.
- ifPresent() 메소드
: Void 타입. 값을 가지고 있는지 확인 후 예외 처리

3) 컨트롤러 구현
: TodoController에 새 PUT 메서드 작성

3-1) 코드 설명
List<TodoDTO> dtos = entities.stream().map(TodoDTO::new).collect(Collectors.toList());

[1] 스트림 생성: entities.stream()은 entities 리스트를 스트림으로 변환합니다.
               스트림은 컬렉션 데이터를 처리하는데 유용한 기능을 제공합니다.

[2] 매핑 (Mapping): map(TodoDTO::new)은 스트림의 각 요소에 대해 TodoDTO::new 람다 표현식을 적용합니다.
                   여기서 TodoDTO::new는 TodoDTO 클래스의 생성자를 참조하는 방법입니다.
                   이를 통해 entities 리스트의 각 요소를 기반으로 새로운 TodoDTO 객체를 생성합니다.

[3] 수집 (Collecting): collect(Collectors.toList())는 스트림의 요소들을 리스트로 수집합니다.
                      collect 메서드는 스트림의 결과를 원하는 형태로 변환할 수 있는 강력한 기능을 제공합니다.
                      이 경우, Collectors.toList()는 스트림의 요소들을 리스트로 수집하게 됩니다.


ResponseDTO<TodoDTO> response = ResponseDTO.<TodoDTO>builder().data(dtos).build();

[1] 빌더 패턴 (Builder Pattern): ResponseDTO.<TodoDTO>builder()는 제네릭 타입이 TodoDTO인 ResponseDTO 객체를 생성하기 위한 빌더를 호출합니다.
                                빌더 패턴은 복잡한 객체를 생성하는데 사용되며, 객체 생성 과정을 더 유연하게 만들어줍니다.

[2] 데이터 설정: .data(dtos) 부분은 ResponseDTO 객체의 data 필드에 dtos 리스트를 설정하는 부분입니다.
                dtos는 이전에 생성한 TodoDTO 객체의 리스트입니다. 이 응답 객체는 클라이언트에게 반환될 데이터를 가지고 있습니다.

[3] 빌드 (Build): .build() 메서드는 빌더를 통해 설정된 정보를 기반으로 최종적인 ResponseDTO 객체를 생성합니다.
이렇게 생성된 response 객체는 클라이언트에게 반환될 응답을 나타내는 객체입니다.

-------------------------------------------------------------
